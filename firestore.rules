
/**
 * @fileoverview Firestore Security Rules for the Bhumi application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model based on Ethereum addresses,
 * denormalized directly onto the Property and related documents.
 *
 * Data Structure:
 * - /properties/{propertyId}: Contains property details, including the owner's Ethereum address (ownerAddress).
 * - /properties/{propertyId}/transferRequests/{transferRequestId}: Contains transfer requests for a specific property.
 * - /properties/{propertyId}/transferEvents/{transferEventId}: Contains historical transfer events for a property.
 * - /submissions/{submissionId}: Contains property submissions pending registrar approval.
 *
 * Key Security Decisions:
 * - Public listing of properties is enabled for discoverability.
 * - Write access to properties is restricted to the property owner (ownerAddress).
 * - Transfer requests and events are linked to properties and inherit the property's ownership constraints.
 *
 * Denormalization for Authorization:
 * - The `Property` document includes `ownerAddress` to enable direct authorization checks without additional `get()` calls.
 *
 * Structural Segregation:
 * - Properties, transfer requests, and transfer events are organized into separate collections for clearer access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allow authenticated users to create submissions and read their own submissions.
     * @path /submissions/{submissionId}
     * @allow create: Any authenticated user can create a submission if the owner matches their UID.
     * @allow read: A user can read a submission if the owner matches their UID.
     * @allow list: A user can query submissions if they filter by their own UID.
     * @allow update, delete: Restricted to registrar/admin roles (not defined in this ruleset).
     * @principle Ensures users can only create and view their own submissions.
     */
    match /submissions/{submissionId} {
      function isSubmissionOwner() {
        return request.auth != null && request.auth.uid == request.resource.data.owner;
      }
      
      function canQueryOwnSubmissions() {
        // Allow list queries if they are scoped to the user's own submissions.
        return request.auth != null && request.query.resource.data.owner == request.auth.uid;
      }

      allow create: if isSubmissionOwner();
      allow read: if request.auth != null && request.auth.uid == resource.data.owner;
      allow list: if canQueryOwnSubmissions();
      allow update, delete: if false; // Only registrar should be able to modify. This will be handled by application logic.
    }
    
    /**
     * @description Grants public read access to properties and restricts write access to the property owner.
     * @path /properties/{propertyId}
     * @allow get, list: Anyone can read property details.
     * @allow create: Only the registrar (matching request.auth.uid) can create a property.
     * @allow update, delete: Only the owner (matching existing resource.data.ownerAddress) can update or delete a property.
     * @deny create: if the `ownerAddress` doesn't exist.
     * @deny update: if attempting to change the `ownerAddress`.
     * @principle Enforces document ownership for writes and public read access.
     */
    match /properties/{propertyId} {
      function isOwner(ownerAddress) {
        return request.auth != null && request.auth.uid == ownerAddress;
      }

      function isValidNewProperty() {
        return request.resource.data.keys().hasAll(['parcelId', 'owner', 'title', 'description', 'area', 'imageUrl', 'ipfsProofCid', 'pointerCid', 'verified', 'txHash', 'forSale', 'price', 'registeredAt', 'history'])
        && request.auth != null; // Simplified: in a real app, check registrar role
      }

      allow get, list: if true;
      allow create: if isValidNewProperty();
      allow update: if isOwner(resource.data.owner) && resource.data.owner == request.resource.data.owner;
      allow delete: if isOwner(resource.data.owner);
    }

    /**
     * @description Restricts access to transfer requests to the property owner.
     * @path /properties/{propertyId}/transferRequests/{transferRequestId}
     * @allow get, list: Only the property owner can view transfer requests.
     * @allow create: Only the property owner can create a transfer request.
     * @allow update, delete: Only the property owner can update or delete a transfer request.
     * @deny create: if the property owner doesn't match the request's sellerAddress.
     * @deny update: if attempting to change the propertyId.
     * @principle Enforces document ownership for writes.
     */
    match /properties/{propertyId}/transferRequests/{transferRequestId} {
      function isPropertyOwner() {
          let propertyDoc = get(/databases/$(database)/documents/properties/$(propertyId));
          return request.auth != null && propertyDoc.data.owner == request.auth.uid;
      }

      function isValidNewTransferRequest() {
        return request.resource.data.keys().hasAll(['id', 'propertyId', 'sellerAddress', 'buyerAddress', 'requestDate', 'status'])
          && request.resource.data.sellerAddress == request.auth.uid;
      }

      allow get, list, create, update, delete: if isPropertyOwner();
    }

    /**
     * @description Restricts access to transfer events to the property owner.
     * @path /properties/{propertyId}/transferEvents/{transferEventId}
     * @allow get, list: Only the property owner can view transfer events.
     * @allow create: Only the registrar (matching request.auth.uid) can create a transfer event.
     * @allow update, delete: No one can update or delete a transfer event once created.
     * @deny create: if the registrarAddress doesn't match request.auth.uid.
     * @principle Enforces document ownership for writes.
     */
    match /properties/{propertyId}/transferEvents/{transferEventId} {
       function isPropertyOwner() {
          let propertyDoc = get(/databases/$(database)/documents/properties/$(propertyId));
          return request.auth != null && propertyDoc.data.owner == request.auth.uid;
      }

      function isValidNewTransferEvent() {
        return request.resource.data.keys().hasAll(['id', 'propertyId', 'transferRequestId', 'sellerAddress', 'buyerAddress', 'eventDate', 'registrarAddress'])
          && request.auth != null; // Simplified: should check registrar role
      }

      allow get, list: if isPropertyOwner();
      allow create: if isValidNewTransferEvent();
      allow update, delete: if false;
    }
  }
}
